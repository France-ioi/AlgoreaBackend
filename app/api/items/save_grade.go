package items

import (
	"crypto/rsa"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strconv"
	"strings"

	"github.com/go-chi/render"
	"github.com/jinzhu/gorm"

	"github.com/France-ioi/AlgoreaBackend/v2/app/database"
	"github.com/France-ioi/AlgoreaBackend/v2/app/formdata"
	"github.com/France-ioi/AlgoreaBackend/v2/app/logging"
	"github.com/France-ioi/AlgoreaBackend/v2/app/payloads"
	"github.com/France-ioi/AlgoreaBackend/v2/app/service"
	"github.com/France-ioi/AlgoreaBackend/v2/app/token"
	"github.com/France-ioi/AlgoreaBackend/v2/golang"
)

// swagger:operation POST /items/save-grade items saveGrade
//
//	---
//	summary: Save the grade
//	description: >
//
//		This service doesn't require authentication. The user is identified by the answer token or by the score token.
//
//
//		Saves the grade returned by a grading app into the `gradings` table and updates the attempt results in the DB.
//		When the `score` is big enough, the service unlocks locked dependent items (if any).
//
//
//		Restrictions:
//
//		* the answer should exist and should have not been graded, otherwise the "forbidden" response is returned.
//	parameters:
//		- in: body
//			name: data
//			required: true
//			schema:
//				type: object
//				properties:
//					score_token:
//						description: A score token generated by the grader (required for platforms supporting tokens, should not be given otherwise)
//						type: string
//					answer_token:
//						description: An answer token generated by AlgoreaBackend (required for platforms not supporting tokens,
//						             ignored otherwise)
//						type: string
//					score:
//						description: A score returned by the grader (required for platforms not supporting tokens, ignored otherwise)
//						type: number
//	responses:
//		"201":
//			description: "Created. Success response."
//			schema:
//					type: object
//					required: [success, message, data]
//					properties:
//						success:
//							description: "true"
//							type: boolean
//							enum: [true]
//						message:
//							description: created
//							type: string
//							enum: [created]
//						data:
//							type: object
//							required: [validated, unlocked_items]
//							properties:
//								validated:
//									description: Whether the full score was obtained on this grading
//									type: boolean
//								unlocked_items:
//									description: Items unlocked by the participant as the result of this grading
//									type: array
//									items:
//										type: object
//										properties:
//											item_id:
//												type: string
//												format: int64
//											type:
//												type: string
//												enum: [Chapter,Task,Skill]
//											title:
//												type: string
//												x-nullable: true
//											language_tag:
//												type: string
//										required: [item_id, type, title, language_tag]
//		"400":
//			"$ref": "#/responses/badRequestResponse"
//		"403":
//			"$ref": "#/responses/forbiddenResponse"
//		"408":
//			"$ref": "#/responses/requestTimeoutResponse"
//		"500":
//			"$ref": "#/responses/internalErrorResponse"
func (srv *Service) saveGrade(responseWriter http.ResponseWriter, httpRequest *http.Request) error {
	store := srv.GetStore(httpRequest)
	requestData := saveGradeRequestParsed{store: store, publicKey: srv.TokenConfig.PublicKey}

	var err error
	if err = render.Bind(httpRequest, &requestData); err != nil {
		return service.ErrInvalidRequest(err)
	}

	logging.LogEntrySetField(httpRequest, "user_id", requestData.ScoreToken.Payload.Converted.UserID)

	var validated, newGradingSaved bool
	unlockedItems := make([]map[string]interface{}, 0)
	err = store.InTransaction(func(store *database.DataStore) error {
		service.MustNotBeError(store.SetPropagationsModeToSync())
		var unlockedItemIDs *golang.Set[int64]
		validated, newGradingSaved, unlockedItemIDs = saveGradingResultsIntoDB(store, &requestData)

		if !newGradingSaved || unlockedItemIDs.Size() == 0 {
			return nil
		}

		service.MustNotBeError(store.Items().Select(`
				items.id AS item_id,
				items.type,
				COALESCE(user_strings.title, default_strings.title) AS title,
				COALESCE(user_strings.language_tag, default_strings.language_tag) AS language_tag`).
			Joins(
				`LEFT JOIN items_strings default_strings
         ON default_strings.item_id = items.id AND default_strings.language_tag = items.default_language_tag`).
			Joins(`LEFT JOIN items_strings user_strings
         ON user_strings.item_id=items.id AND user_strings.language_tag = (SELECT default_language FROM users WHERE group_id = ?)`,
				requestData.ScoreToken.Payload.Converted.UserID).
			Where("items.id IN (?)", unlockedItemIDs.Values()).
			Order("items.id").
			ScanIntoSliceOfMaps(&unlockedItems).Error())

		return nil
	})
	service.MustNotBeError(err)

	if !newGradingSaved {
		return service.ErrForbidden(errors.New("the answer has been already graded or is not found"))
	}

	service.MustNotBeError(render.Render(responseWriter, httpRequest, service.CreationSuccess(map[string]interface{}{
		"validated":      validated,
		"unlocked_items": service.ConvertSliceOfMapsFromDBToJSON(unlockedItems),
	})))
	return nil
}

func saveGradingResultsIntoDB(store *database.DataStore, requestData *saveGradeRequestParsed) (
	validated, ok bool, unlockedItemIDs *golang.Set[int64],
) {
	score := requestData.ScoreToken.Payload.Converted.Score

	const maxScore = 100
	gotFullScore := score == maxScore
	validated = gotFullScore // currently a validated task is only a task with a full score (score == 100)
	if !saveNewScoreIntoGradings(store, requestData, score) {
		return validated, false, golang.NewSet[int64]()
	}

	// Build query to update results
	columnsToUpdate := []string{
		"tasks_tried",
		"score_obtained_at",
		"score_computed",
	}
	newScoreExpression := gorm.Expr(`
			LEAST(GREATEST(
				CASE score_edit_rule
					WHEN 'set' THEN score_edit_value
					WHEN 'diff' THEN ? + score_edit_value
					ELSE ?
				END, score_computed, 0), 100)`, score, score)
	values := []interface{}{
		requestData.ScoreToken.Payload.Converted.UserAnswerID, // for join
		1, // tasks_tried
		// for score_computed we compare patched scores
		gorm.Expr(`
			CASE
			  -- New best score or no time saved yet
				-- Note that when the score = 0, score_obtained_at is the time of the first submission
				WHEN score_obtained_at IS NULL OR score_computed < ? THEN answers.created_at
				-- We may get the result of an earlier submission after one with the same score
				WHEN score_computed = ? THEN LEAST(score_obtained_at, answers.created_at)
				-- New score if lower than the best score
				ELSE score_obtained_at
			END`, newScoreExpression, newScoreExpression), // score_obtained_at
		newScoreExpression, // score_computed
	}
	if validated {
		// Item was validated
		columnsToUpdate = append(columnsToUpdate, "validated_at")
		values = append(values, gorm.Expr("LEAST(IFNULL(validated_at, answers.created_at), answers.created_at)"))
	}

	updateExpr := "SET " + strings.Join(columnsToUpdate, " = ?, ") + " = ?"
	values = append(values,
		requestData.ScoreToken.Payload.Converted.ParticipantID,
		requestData.ScoreToken.Payload.Converted.AttemptID,
		requestData.ScoreToken.Payload.Converted.LocalItemID,
	)
	service.MustNotBeError(
		store.DB.Exec("UPDATE results JOIN answers ON answers.id = ? "+
			updateExpr+" WHERE results.participant_id = ? AND results.attempt_id = ? AND results.item_id = ?", values...).
			Error())
	resultStore := store.Results()
	service.MustNotBeError(resultStore.MarkAsToBePropagated(
		requestData.ScoreToken.Payload.Converted.ParticipantID, requestData.ScoreToken.Payload.Converted.AttemptID,
		requestData.ScoreToken.Payload.Converted.LocalItemID, false))

	unlockedItemIDs, err := resultStore.PropagateAndCollectUnlockedItemsForParticipant(requestData.ScoreToken.Payload.Converted.ParticipantID)
	service.MustNotBeError(err)

	return validated, true, unlockedItemIDs
}

func saveNewScoreIntoGradings(store *database.DataStore, requestData *saveGradeRequestParsed, score float64) bool {
	answerID := requestData.ScoreToken.Payload.Converted.UserAnswerID
	gradingStore := store.Gradings()

	insertError := gradingStore.InsertMap(map[string]interface{}{
		"answer_id": answerID, "score": score, "graded_at": database.Now(),
	})

	// ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (the answer has been removed)
	if insertError != nil && database.IsForeignConstraintError(insertError) {
		return false
	}

	// ERROR 1062 (23000): Duplicate entry (already graded)
	if insertError != nil && database.IsDuplicateEntryError(insertError) {
		var oldScore *float64
		service.MustNotBeError(gradingStore.
			Where("answer_id = ?", answerID).PluckFirst("score", &oldScore).Error())
		if oldScore != nil {
			if *oldScore != score {
				//nolint:errchkjson // no error: only strings and floats previously decoded from JSON
				fieldsForLoggingMarshaled, _ := json.Marshal(map[string]interface{}{
					"idAttempt":    requestData.ScoreToken.Payload.AttemptID,
					"idItem":       requestData.ScoreToken.Payload.LocalItemID,
					"idUser":       requestData.ScoreToken.Payload.UserID,
					"idUserAnswer": requestData.ScoreToken.Payload.UserAnswerID,
					"newScore":     score,
					"oldScore":     *oldScore,
				})
				logging.EntryFromContext(store.GetContext()).
					Warnf("A user tries to replay a score token with a different score value (%s)", fieldsForLoggingMarshaled)
			}
			return false
		}
	}
	service.MustNotBeError(insertError)

	return true
}

type saveGradeRequestParsed struct {
	ScoreToken  *token.Token[payloads.ScoreToken]
	AnswerToken *token.Token[payloads.AnswerToken]

	store     *database.DataStore
	publicKey *rsa.PublicKey
}

type saveGradeRequest struct {
	ScoreToken  *formdata.Anything `json:"score_token"`
	Score       *float64           `json:"score"`
	AnswerToken *formdata.Anything `json:"answer_token"`

	store *database.DataStore
}

// UnmarshalJSON unmarshals the items/saveGrade request data from JSON.
func (requestData *saveGradeRequestParsed) UnmarshalJSON(raw []byte) error {
	var wrapper saveGradeRequest
	wrapper.store = requestData.store
	if err := json.Unmarshal(raw, &wrapper); err != nil {
		return err
	}

	return requestData.unmarshalScoreToken(&wrapper)
}

func (requestData *saveGradeRequestParsed) unmarshalScoreToken(wrapper *saveGradeRequest) error {
	if wrapper.ScoreToken == nil {
		return requestData.reconstructScoreTokenData(wrapper)
	}

	// We need the `idItemLocal` to get the platform's public key, and verify the signature of the token.
	// So we need to extract it before we can unmarshal (which also verifies the signature) the token.
	localItemIDUnsafeRaw, err := token.GetUnsafeFromToken(wrapper.ScoreToken.Bytes(), "idItemLocal")
	if err != nil {
		return fmt.Errorf("invalid score_token: %w", err)
	}

	localItemIDUnsafeString, ok := localItemIDUnsafeRaw.(string)
	if !ok {
		return errors.New("invalid score_token: invalid idItemLocal: should be a string")
	}

	localItemIDUnsafe, err := strconv.ParseInt(localItemIDUnsafeString, 10, 64)
	if err != nil {
		return fmt.Errorf("invalid score_token: invalid idItemLocal: %w", err)
	}

	hasPlatformKey, err := token.UnmarshalDependingOnItemPlatform(
		requestData.store,
		localItemIDUnsafe,
		&requestData.ScoreToken,
		wrapper.ScoreToken.Bytes(),
		"score_token",
	)
	if err != nil && !token.IsUnexpectedError(err) {
		return err
	}
	service.MustNotBeError(err)

	if !hasPlatformKey {
		return errors.New("the platform does not have a public key, but the score_token is given")
	}

	return nil
}

func (requestData *saveGradeRequestParsed) unmarshalAnswerToken(wrapper *saveGradeRequest) error {
	if wrapper.AnswerToken == nil {
		return errors.New("either score_token or answer_token should be given")
	}
	requestData.AnswerToken = &token.Token[payloads.AnswerToken]{PublicKey: requestData.publicKey}
	if err := requestData.AnswerToken.UnmarshalJSON(wrapper.AnswerToken.Bytes()); err != nil {
		return fmt.Errorf("invalid answer_token: %s", err.Error())
	}

	itemID := requestData.AnswerToken.Payload.Converted.LocalItemID
	publicKey, err := requestData.store.Platforms().GetPublicKeyByItemID(itemID)
	if gorm.IsRecordNotFoundError(err) {
		return fmt.Errorf("cannot find the platform for item %d", itemID)
	}
	service.MustNotBeError(err)

	if publicKey != nil {
		return errors.New("the platform has a public key, but the score_token is not given")
	}

	return nil
}

func (requestData *saveGradeRequestParsed) reconstructScoreTokenData(wrapper *saveGradeRequest) error {
	if err := requestData.unmarshalAnswerToken(wrapper); err != nil {
		return err
	}
	if wrapper.Score == nil {
		return errors.New("missing score which is required when the platform does not have a public key")
	}

	requestData.ScoreToken = &token.Token[payloads.ScoreToken]{Payload: payloads.ScoreToken{
		Converted: payloads.ScoreTokenConverted{
			Score:         *wrapper.Score,
			UserID:        requestData.AnswerToken.Payload.Converted.UserID,
			UserAnswerID:  requestData.AnswerToken.Payload.Converted.UserAnswerID,
			LocalItemID:   requestData.AnswerToken.Payload.Converted.LocalItemID,
			ParticipantID: requestData.AnswerToken.Payload.Converted.ParticipantID,
			AttemptID:     requestData.AnswerToken.Payload.Converted.AttemptID,
		},
		ItemURL:     requestData.AnswerToken.Payload.ItemURL,
		AttemptID:   requestData.AnswerToken.Payload.AttemptID,
		LocalItemID: requestData.AnswerToken.Payload.LocalItemID,
	}}
	return nil
}

// Bind of saveGradeRequestParsed does nothing.
func (requestData *saveGradeRequestParsed) Bind(*http.Request) error {
	return nil
}
