package items

import (
	"bytes"
	"crypto/rsa"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"strconv"

	"github.com/go-chi/render"
	"github.com/jinzhu/gorm"

	"github.com/France-ioi/AlgoreaBackend/v2/app/database"
	"github.com/France-ioi/AlgoreaBackend/v2/app/formdata"
	"github.com/France-ioi/AlgoreaBackend/v2/app/logging"
	"github.com/France-ioi/AlgoreaBackend/v2/app/payloads"
	"github.com/France-ioi/AlgoreaBackend/v2/app/service"
	"github.com/France-ioi/AlgoreaBackend/v2/app/token"
)

// swagger:operation POST /items/ask-hint items itemGetHintToken
//
//	---
//	summary: Register a hint request
//	description: >
//
//		Saves the hint request into `results` and generates a new task token.
//
//
//		This service doesn't require authentication. The user is identified by the task token.
//
//
//		Restrictions:
//
//			* The task token's user should have submission rights to the `task_token`'s item,
//				otherwise the "forbidden" response is returned.
//			* There should be a row in the `results` with `participant_id`, `attempt_id`, and `item_id` matching the tokens
//				and `attempts.allows_submissions_until` should be equal to time in the future,
//				otherwise the "not found" response is returned.
//
//	parameters:
//		- in: body
//			name: data
//			required: true
//			schema:
//				type: object
//				required: [task_token, hint_token]
//				properties:
//					task_token:
//						description: A JWS task token previously generated by AlgoreaBackend
//						type: string
//					hint_requested:
//						description: A JWS hint request token generated by a task platform
//						type: string
//	responses:
//		"201":
//			description: "Created. Success response with the newly created task token"
//			schema:
//				type: object
//				required: [success, message, data]
//				properties:
//					success:
//						description: "true"
//						type: boolean
//						enum: [true]
//					message:
//						description: created
//						type: string
//						enum: [created]
//					data:
//						type: object
//						required: [task_token]
//						properties:
//							task_token:
//								type: string
//		"400":
//			"$ref": "#/responses/badRequestResponse"
//		"403":
//			"$ref": "#/responses/forbiddenResponse"
//		"404":
//			"$ref": "#/responses/notFoundResponse"
//		"408":
//			"$ref": "#/responses/requestTimeoutResponse"
//		"500":
//			"$ref": "#/responses/internalErrorResponse"
func (srv *Service) askHint(responseWriter http.ResponseWriter, httpRequest *http.Request) error {
	store := srv.GetStore(httpRequest)
	requestData := AskHintRequest{store: store, publicKey: srv.TokenConfig.PublicKey}

	var err error
	if err = render.Bind(httpRequest, &requestData); err != nil {
		return service.ErrInvalidRequest(err)
	}

	service.MustNotBeError(
		checkHintOrScoreTokenRequiredFields(&requestData.TaskToken.Payload,
			"hint_requested",
			requestData.HintToken.Payload.Converted.UserID, requestData.HintToken.Payload.LocalItemID,
			requestData.HintToken.Payload.ItemURL, requestData.HintToken.Payload.AttemptID))

	logging.LogEntrySetField(httpRequest, "user_id", requestData.TaskToken.Payload.Converted.UserID)

	err = store.InTransaction(func(store *database.DataStore) error {
		var hasAccess bool
		var reason error
		hasAccess, reason, err = store.Items().
			CheckSubmissionRights(requestData.TaskToken.Payload.Converted.ParticipantID, requestData.TaskToken.Payload.Converted.LocalItemID)
		service.MustNotBeError(err)

		if !hasAccess {
			return service.ErrForbidden(reason) // rollback
		}

		// Get the previous hints requested JSON data
		var hintsRequestedParsed []*formdata.Anything
		hintsRequestedParsed, err = queryAndParsePreviouslyRequestedHints(&requestData.TaskToken.Payload, store, httpRequest)
		if gorm.IsRecordNotFoundError(err) {
			return service.ErrNotFound(errors.New("no result or the attempt is expired")) // rollback
		}
		service.MustNotBeError(err)

		// Add the new requested hint to the list if it's not in the list yet
		hintsRequestedParsed = addHintToListIfNeeded(hintsRequestedParsed, requestData.HintToken.Payload.AskedHint)

		var hintsRequestedNew []byte
		hintsRequestedNew, err = json.Marshal(hintsRequestedParsed)
		service.MustNotBeError(err)
		hintsRequestedNewString := string(hintsRequestedNew)
		requestData.TaskToken.Payload.HintsRequested = &hintsRequestedNewString
		hintsGivenCountString := strconv.Itoa(len(hintsRequestedParsed))
		requestData.TaskToken.Payload.HintsGivenCount = &hintsGivenCountString

		resultStore := store.Results()
		// Update results with the hint request
		service.MustNotBeError(resultStore.
			Where("participant_id = ?", requestData.TaskToken.Payload.Converted.ParticipantID).
			Where("attempt_id = ?", requestData.TaskToken.Payload.Converted.AttemptID).
			Where("item_id = ?", requestData.TaskToken.Payload.Converted.LocalItemID).
			UpdateColumn(map[string]interface{}{
				"tasks_with_help":    1,
				"latest_activity_at": database.Now(),
				"latest_hint_at":     database.Now(),
				"hints_requested":    hintsRequestedNew,
				"hints_cached":       len(hintsRequestedParsed),
			}).Error())
		service.MustNotBeError(resultStore.MarkAsToBePropagated(
			requestData.TaskToken.Payload.Converted.ParticipantID, requestData.TaskToken.Payload.Converted.AttemptID,
			requestData.TaskToken.Payload.Converted.LocalItemID, true))

		return nil
	})
	service.MustNotBeError(err)

	requestData.TaskToken.Payload.PlatformName = srv.TokenConfig.PlatformName
	newTaskToken, err := requestData.TaskToken.Sign(srv.TokenConfig.PrivateKey)
	service.MustNotBeError(err)

	service.MustNotBeError(render.Render(responseWriter, httpRequest, service.CreationSuccess(map[string]interface{}{
		"task_token": newTaskToken,
	})))
	return nil
}

func queryAndParsePreviouslyRequestedHints(
	taskTokenPayload *payloads.TaskToken, store *database.DataStore, httpRequest *http.Request,
) ([]*formdata.Anything, error) {
	hintsInfo, err := store.Results().GetHintsInfoForActiveAttempt(
		taskTokenPayload.Converted.ParticipantID,
		taskTokenPayload.Converted.AttemptID,
		taskTokenPayload.Converted.LocalItemID)
	var hintsRequestedParsed []*formdata.Anything
	if err == nil && hintsInfo.HintsRequested != nil {
		hintsErr := json.Unmarshal([]byte(*hintsInfo.HintsRequested), &hintsRequestedParsed)
		if hintsErr != nil {
			hintsRequestedParsed = nil
			fieldsForLoggingMarshaled, _ := json.Marshal(map[string]string{
				"idUser":      taskTokenPayload.UserID,
				"idItemLocal": taskTokenPayload.LocalItemID,
				"idAttempt":   taskTokenPayload.AttemptID,
			})
			logging.GetLogEntry(httpRequest).Warnf("Unable to parse hints_requested (%s) having value %q: %s", fieldsForLoggingMarshaled,
				*hintsInfo.HintsRequested, hintsErr.Error())
		}
	}
	return hintsRequestedParsed, err
}

func addHintToListIfNeeded(hintsList []*formdata.Anything, hintToAdd *formdata.Anything) []*formdata.Anything {
	var hintFound bool
	for _, hint := range hintsList {
		if bytes.Equal(hint.Bytes(), hintToAdd.Bytes()) {
			hintFound = true
			break
		}
	}
	if !hintFound {
		hintsList = append(hintsList, hintToAdd)
	}
	return hintsList
}

// AskHintRequest represents a JSON request body format needed by items.askHint().
type AskHintRequest struct {
	TaskToken *token.Token[payloads.TaskToken]
	HintToken *token.Token[payloads.HintToken]

	store     *database.DataStore
	publicKey *rsa.PublicKey
}

type askHintRequestWrapper struct {
	TaskToken          *string            `json:"task_token"`
	HintRequestedToken *formdata.Anything `json:"hint_requested"`
}

// UnmarshalJSON unmarshals the items/askHint request data from JSON.
func (requestData *AskHintRequest) UnmarshalJSON(raw []byte) error {
	var wrapper askHintRequestWrapper
	if err := json.Unmarshal(raw, &wrapper); err != nil {
		return err
	}
	if wrapper.TaskToken == nil {
		return errors.New("missing task_token")
	}
	requestData.TaskToken = &token.Token[payloads.TaskToken]{PublicKey: requestData.publicKey}
	if err := requestData.TaskToken.UnmarshalString(*wrapper.TaskToken); err != nil {
		return fmt.Errorf("invalid task_token: %s", err.Error())
	}
	return requestData.unmarshalHintToken(&wrapper)
}

// Bind of AskHintRequest checks that the asked hint is present.
func (requestData *AskHintRequest) Bind(_ *http.Request) error {
	if len(requestData.HintToken.Payload.AskedHint.Bytes()) == 0 ||
		bytes.Equal([]byte("null"), requestData.HintToken.Payload.AskedHint.Bytes()) {
		return errors.New("asked hint should not be empty")
	}
	return nil
}

func (requestData *AskHintRequest) unmarshalHintToken(wrapper *askHintRequestWrapper) error {
	if wrapper.HintRequestedToken == nil {
		return errors.New("missing hint_requested")
	}

	itemID := requestData.TaskToken.Payload.Converted.LocalItemID
	platformHasKey, err := token.UnmarshalDependingOnItemPlatform(
		requestData.store,
		itemID,
		&requestData.HintToken,
		wrapper.HintRequestedToken.Bytes(),
		"hint_requested",
	)
	if err != nil && !token.IsUnexpectedError(err) {
		return err
	}
	service.MustNotBeError(err)

	if !platformHasKey {
		return fmt.Errorf("no public key available for the platform linked to item %d", itemID)
	}

	return nil
}
